.program rowwrite

; // Just row write is done by PIO, rest of the display driver is just software. Later, maybe more functinality could be moved to PIO, but row write is the slowest bit
; // also, by using PIO, DMA can be used to move data to the display so the CPU has more free time for other tasks

; // notes:
; // the 3 pin groups are used as folows:
; // out pin group for data
; // sideset pins for clock CKV and CL (in that order, so CKV is clock_basepin and CL clock_basepin+1. So when sidesetting them, LSB is CKV, MSB is CL)
; // set pin group for LE OE SPH SPV GMODE1 (in that order, so LE is control_basepin and OE control_basepin+! etc. so LE is MSB, GMODE MSB.) 

; // autopull is used for data

; // opt. start_scan could also be done by pio maybe? If so, include SPV and VCLK. VCLK in side, SPV in pins

.side_set 2;

.wrap_target 
// row write
set pins 0b01100 side 0b00;//default alleen SPH en SPV 1, rest 0
pull ifempty side 0b00; // It will wait here for data: Autopull is enabled, so this is a nop UNLESS it has to wait for data, then it will stall. 

//vscan start: GMODE 1, vclk, SPV0, VCLK MAAR HOOG LATEN, SPV1, vlck
set pins 0b11100 side 0b00;
nop [0] side 0b01; // todo: maybe no extra wait because it takes 1 tick anyway? SO not [1] and [4] but [0] and [3]
set x 20 [3] side 0b00;
set pins 0b10100 side 0b00
nop [0] side 0b01;
set y 10 [3] side 0b00;
nop side 0b01; // CKV should go high a bit early here...
set pins 0b11100 [1] side 0b01
nop [3] side 0b00;

colloop: //collumn loop
//hscan start
set pins 0b11000 side 0b00;

rowloop: // 200 bytes per row (800 pixels)
//hscan write (rowwrwrite)
out pins 8 side 0b00;
nop side 0b10; 
jmp x-- rowloop side 0b00;
set x 20 side 0b00
jmp y-- rowloop side 0b00;
// end rowloop

//hscan stop
set pins 0b11100 side 0b00;
set y 30 side 0b10;
nop side 0b00; // todo: can this be eliminated since it is set 0 on next anyway?
set pins 0b11101 [1] side 0b00; // TODO: clock delay?
set pins 0b11100 side 0b00;

//vscan_write
set pins 0b11110 [5] side 0b01; // set ckv and oe and wait 5 us
waitabit:
set pins 0b11100 [6] side 0b00; // clear ckv and oe and wait 200 us (maybe grayscale timing?)
nop [2] side 0b00;
// delay is max 7, so make a loop. x is still 20 from last loop
jmp x-- waitabit side 0b00;

//end colloop
;// for 600 rows: (30 times 20), or rather simpy untill data runs out because out of scratch registers...
JMP !OSRE colloop side 0;

//vscan_stop: gmode 0 and 5 vlclks
set pins 0b01100 side 0b00;
set x 5 side 0b01;
vclkloop:
nop side 0b00;
jmp x-- vclkloop side 0b01;

.wrap

% c-sdk {
    #include "hardware/clocks.h"
static inline void rowwrite_program_init(PIO pio, uint sm, uint offset, uint datapin_base, uint clocks_base , uint control_base) {
    // control_base: LE (Next OE, SPH, SPV)
    // data_base: first data pin
    // clocks_base: CL (next ckv)
    pio_sm_config c = rowwrite_program_get_default_config(offset);

//set pins for use with SET
    sm_config_set_set_pins(&c,control_base,5); 
     // Set this pin's GPIO function (connect PIO to the pad)
    for(int i=0;i<5;i++){
        pio_gpio_init(pio, control_base+i);
    }
    // Set the pin direction to output at the PIO
    pio_sm_set_consecutive_pindirs(pio, sm, control_base, 5, true);
//  set pins for use with OUT
    sm_config_set_out_pins(&c, datapin_base, 8);
    // Set this pin's GPIO function (connect PIO to the pad)
        for(uint i=0;i<8;i++){
            pio_gpio_init(pio, datapin_base+i);
        }
    // Set the pin direction to output at the PIO
    pio_sm_set_consecutive_pindirs(pio, sm, datapin_base, 8, true);
// set pins for use with SIDE_SET
    sm_config_set_sideset_pins (&c,clocks_base); //side-set gpio gp2 -- NOTE: sm_config_set_sideset_pins is not pio_sm_set_sideset_pins! 
    pio_gpio_init(pio,clocks_base); 
    pio_gpio_init(pio,clocks_base+1); 
    pio_sm_set_consecutive_pindirs(pio, sm, clocks_base, 2, true);//set output for the side-set pin

    float div = clock_get_hz(clk_sys) / 1000000; // 1 cycle should be 1 us, so run at 1 MHz
    //float div = clock_get_hz(clk_sys) / 50000; // try 50 kHz instead too see if 1 MHz is too fast?
    //float div = clock_get_hz(clk_sys) / 100000;

    sm_config_set_clkdiv(&c,div);

    //join both 4-level fifo's into one output fifo (8 levels)
    sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_TX);

    sm_config_set_out_shift(&c, true,true,32); // autopull when 32 bits have been shifted out, right

    // Load our configuration, and jump to the start of the program
    pio_sm_init(pio, sm, offset, &c);
    // Set the state machine running
    pio_sm_set_enabled(pio, sm, true);
}


int DMA_setup_eink_rowwrite(void * dispdata, const uint SIZE, PIO pio, uint sm, int* pdmach)
{
    // dispdata: pointer to display data buffer (the data to write to the rows)
    // PIO and SM: the pio and statemachine to write this data to TODO: could be pointers?

    // *pdmach:  returns a pointer to the dma channel claimed for this
    // returns 1 on succes, -1 on failure

    static int dmach;
    dmach = dma_claim_unused_channel(true);
    if(-1==dmach) return -1; // no free DMA Channel
    dma_channel_config eink_dma_ch_config = dma_channel_get_default_config(dmach);
    //default config has read increment and write to fixed adres, 32 bits wide, which is indeed what's needed here

    uint dreq = pio_get_dreq(pio,sm,true); // get the correct DREQ for this pio & statemachine
    channel_config_set_dreq(&eink_dma_ch_config, dreq); // sets DREQ

// write the config and DO NOT YET start the transfer
   dma_channel_configure(
        dmach, 
        &eink_dma_ch_config,
        &pio->txf[sm],
        &dispdata,
        SIZE,
        false // true to start imeadeately, false to start later
    );
    pdmach=&dmach;
return 1; 
}


int start_a_dma_eink_rowwrite(uint* dmach, void* dispdata, PIO pio)
{
    //*dmach: pointer to the dma ch to start, 
    // dispdata: pointer to display data buffer (the data to write to the rows)
    // // PIO: the pio to write this data to TODO could be pointer?
    // returns 1 on succes, 0 when still bussy from previous write, -1 on failure

     if(!dma_channel_is_busy(*dmach))// TODO: this triggers a HARDFAULT! (Interrupt fout?)
        {
            // once DMA is no longer busy, load new data and restart transfer           
            dma_channel_set_read_addr(*dmach, dispdata, true); // re-set read adress and restart transfer
        }
        else return 0; // still busy

return 1; 
}

%}