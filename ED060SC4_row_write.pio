.program rowwrite

; // Just row write is done by PIO, rest of the display driver is just software. Later, maybe more functinality could be moved to PIO, but row write is the slowest bit
; // also, by using PIO, DMA can be used to move data to the display so the CPU has more free time for other tasks

; // notes:
; // the 3 pin groups are used as folows:
; // out pin group for data
; // sideset pins for clock CL and CKV (in that order)
; // set pin group for LE OE SPH SPV GMODE1 (in that order)

; // autopull is used for data

; // opt. start_scan could also be done by pio maybe? If so, include SPV and VCLK. VCLK in side, SPV in pins

.side_set 2;

.wrap_target 
// row write
pull ifempty side 0b00; // It will wait here for data: Autopull is enabled, so this is a nop UNLESS it has to wait for data, then it will stall. 
; // start Vscan (col) GMODE 1 (already is), CKV1/0 with pause, SPV0, CKC1/0, SPV1, CKV1/0
set pins 0b11111 side 0b01;
nop [4] side 0b00;
set pins 0b11101 side 0b01;
nop [4] side 0b00;
set pins 0b11111 side 0b01;
nop [4] side 0b00;

; // start Hscan (row)
set pins 0b11111 side 0b11; // LE H and 2 clock pulses
nop side 0b10;
nop side 0b11;
nop side 0b10;
set pins 0b01111 side 0b11; // LE L and 2 clock pulses
nop side 0b10;
set y 10 side 0b11; // instead of nops, already set the loop iteration counters
colloop:
set x 20 side 0b10; // maximum 5 bits, so max 31, so 20 is good
colloop2:
set pins 0b01011 side 0b10; // set OE High SPH low, LE stays low
rowloop: ;// iterate for each row 20*10=200 bytes per row -- rowwrite loop
out pins 8 side 0b11 [2] ; // set data out, raise clock, and delay a bit
jmp x-- rowloop side 0b10;
set x 20 side 0b10;
jmp y-- rowloop side 0b10;

;// write out (OE) and next row (SPH, CKV) 
set pins 0b01111 side 0b11; // SPH H and 2 clks
nop side 0b10; 
nop side 0b11;
nop side 0b10;

set pins 0b00111 [4] side 0b01 // ckv L, OE L, 2 clocks
nop side 0b00; 
nop side 0b01;
nop side 0b10; // CKV H

;// for 600 rows: (30 times 20)
jmp y-- colloop side 0b10;
set y 30 side 0b10;
jmp x-- colloop2 side 0b10;

//todo: hscan stop? No, that is already in the SPH1, LE1 and 2 clocks, LE0 above...


// todo: greyscale timing? But that is another wave shape!
// Todo: maybe other waveshape(s) take less PIO instructions?
// todo: maybe split up to multiple statmachines. One for data, one for control bits, both driven from data in RAM (OUT instructions to set pins to values from array, delays also from aray so variable timing is possible)
// TODO: re-do all this based on Peteri Aimonens code, as that is more readable/clearer

.wrap

% c-sdk {
    #include "hardware/clocks.h"
static inline void rowwrite_program_init(PIO pio, uint sm, uint offset, uint datapin_base, uint clocks_base , uint control_base) {
    // control_base: LE (Next OE, SPH, SPV)
    // data_base: first data pin
    // clocks_base: CL (next ckv)
    pio_sm_config c = rowwrite_program_get_default_config(offset);

//set pins for use with SET
    sm_config_set_set_pins(&c,control_base,5); 
     // Set this pin's GPIO function (connect PIO to the pad)
    for(int i=0;i<5;i++){
        pio_gpio_init(pio, control_base+i);
    }
    // Set the pin direction to output at the PIO
    pio_sm_set_consecutive_pindirs(pio,sm,control_base,5,true);
//  set pins for use with OUT
    sm_config_set_out_pins(&c, datapin_base, 8);
    // Set this pin's GPIO function (connect PIO to the pad)
        for(uint i=0;i<8;i++){
            pio_gpio_init(pio, datapin_base+i);
        }
    // Set the pin direction to output at the PIO
    pio_sm_set_consecutive_pindirs(pio, sm, datapin_base, 8, true);
// set pins for use with SIDE_SET
    sm_config_set_sideset_pins (&c,clocks_base); //side-set gpio gp2 -- NOTE: sm_config_set_sideset_pins is not pio_sm_set_sideset_pins! 
    pio_gpio_init(pio,clocks_base); 
    pio_gpio_init(pio,clocks_base+1); 
    pio_sm_set_consecutive_pindirs(pio, sm, clocks_base, 2, true);//set output for the side-set pin

    float div = clock_get_hz(clk_sys) / 1000000; // 1 cycle should be 1 us, so run at 1 MHz
    //float div = clock_get_hz(clk_sys) / 50000; // try 50 kHz instead too see if 1 MHz is too fast?
    //float div = clock_get_hz(clk_sys) / 500;

    sm_config_set_clkdiv(&c,div);

    //join both 4-level fifo's into one output fifo (8 levels)
    sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_TX);

    sm_config_set_out_shift(&c, true,true,32); // autopull when 32 bits have been shifted out, right

    // Load our configuration, and jump to the start of the program
    pio_sm_init(pio, sm, offset, &c);
    // Set the state machine running
    pio_sm_set_enabled(pio, sm, true);
}


int DMA_setup_eink_rowwrite(void * dispdata, const uint SIZE, PIO pio, uint sm, int* pdmach)
{
    // dispdata: pointer to display data buffer (the data to write to the rows)
    // PIO and SM: the pio and statemachine to write this data to TODO: could be pointers?

    // *pdmach:  returns a pointer to the dma channel claimed for this
    // returns 1 on succes, -1 on failure

    static int dmach;
    dmach = dma_claim_unused_channel(true);
    if(-1==dmach) return -1; // no free DMA Channel
    dma_channel_config eink_dma_ch_config = dma_channel_get_default_config(dmach);
    //default config has read increment and write to fixed adres, 32 bits wide, which is indeed what's needed here

    uint dreq = pio_get_dreq(pio,sm,true); // get the correct DREQ for this pio & statemachine
    channel_config_set_dreq(&eink_dma_ch_config, dreq); // sets DREQ

// write the config and DO NOT YET start the transfer
   dma_channel_configure(
        dmach, 
        &eink_dma_ch_config,
        &pio->txf[sm],
        &dispdata,
        SIZE,
        false // true to start imeadeately, false to start later
    );
    pdmach=&dmach;
return 1; 
}


int start_a_dma_eink_rowwrite(uint* dmach, void* dispdata, PIO pio)
{
    //*dmach: pointer to the dma ch to start, 
    // dispdata: pointer to display data buffer (the data to write to the rows)
    // // PIO: the pio to write this data to TODO could be pointer?
    // returns 1 on succes, 0 when still bussy from previous write, -1 on failure

     if(!dma_channel_is_busy(*dmach))// TODO: this triggers a HARDFAULT! (Interrupt fout?)
        {
            // once DMA is no longer busy, load new data and restart transfer           
            dma_channel_set_read_addr(*dmach, dispdata, true); // re-set read adress and restart transfer
        }
        else return 0; // still busy

return 1; 
}

%}